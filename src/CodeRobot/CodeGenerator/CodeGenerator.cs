// Copyright (c) rigofunc (xuyingting). All rights reserved.

using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using CodeRobot.Database.RevEng;

using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace CodeRobot.Generator
{
    /// <summary>
    /// Represents the base code generator, which implements the <see cref="ICodeGenerator"/> interfaces.
    /// </summary>
    public class CodeGenerator : ICodeGenerator
    {
        private const string HEADCOMMENT =
@"//--------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by tools developed by rigofunc (xuyingting).
//     
//     Copyright (c) rigofunc (xuyingting). All rights reserved.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//--------------------------------------------------------------------------";

        protected readonly ITypeSyntaxProvider _typeSyntaxProvider;
        protected readonly IDatabaseIdioms _databaseIdioms;
        private string _namespace;

        /// <summary>
        /// Initializes a new instances of the <see cref="CodeGenerator"/> class.
        /// </summary>
        /// <param name="typeSyntaxProvider">The <see cref="ITypeSyntaxProvider"/>, if the value is null, will use the <see cref="DefaultTypeSyntaxProvider"/>.</param>
        /// <param name="databaseIdioms">The database idioms.</param>
        public CodeGenerator(IDatabaseIdioms databaseIdioms, ITypeSyntaxProvider typeSyntaxProvider = null)
        {
            _databaseIdioms = databaseIdioms;
            _typeSyntaxProvider = typeSyntaxProvider ?? new DefaultTypeSyntaxProvider();
        }

        /// <summary>
        /// Generates source code from <paramref name="databaseModel"/>, <seealso cref="DatabaseModel"/>
        /// </summary>
        /// <param name="databaseModel">The database model.</param>
        /// <param name="namespace">The namespace for the generated class, if null, will use the namespace of the this tools.</param>
        /// <returns>A range of syntax node and its corresponded object name.</returns>
        public IEnumerable<(string name, SyntaxNode syntaxNode)> Generate(DatabaseModel databaseModel, string @namespace = null)
        {
            if (string.IsNullOrEmpty(@namespace))
            {
                _namespace = "CodeRobot";
            }
            else
            {
                _namespace = @namespace;
            }

            foreach (var syntax in VisitDatabase(databaseModel))
            {
                yield return (syntax.Identifier.ToString(), CreateCompilationUnit(syntax));
            }
        }

        /// <summary>
        /// Creates the compilation unit for the specified <paramref name="typeDeclarationSyntax"/>.
        /// </summary>
        /// <param name="typeDeclarationSyntax">The <see cref="BaseTypeDeclarationSyntax"/></param>
        /// <returns>The <see cref="CompilationUnitSyntax"/></returns>
        protected virtual CompilationUnitSyntax CreateCompilationUnit(BaseTypeDeclarationSyntax typeDeclarationSyntax)
        {
            return CompilationUnit()
                    .WithUsings(
                        List(
                            new UsingDirectiveSyntax[] {
                                UsingDirective(IdentifierName("System"))
                                    .WithUsingKeyword(
                                        Token(
                                            TriviaList(
                                                Comment(HEADCOMMENT)),
                                        SyntaxKind.UsingKeyword,
                                        TriviaList())),
                                UsingDirective(
                                    QualifiedName(
                                        QualifiedName(
                                            IdentifierName("System"),
                                            IdentifierName("Collections")),
                                        IdentifierName("Generic")))
                            }))
                    .WithMembers(
                        SingletonList<MemberDeclarationSyntax>(
                            NamespaceDeclaration(
                                IdentifierName(_namespace))
                                .WithMembers(
                                    SingletonList<MemberDeclarationSyntax>(typeDeclarationSyntax))))
                    .NormalizeWhitespace();
        }

        protected virtual SyntaxList<BaseTypeDeclarationSyntax> VisitDatabase(DatabaseModel databaseModel)
        {
            return List(from table in databaseModel.Tables
                        select VisitTable(table)
                        );
        }

        protected virtual BaseTypeDeclarationSyntax VisitTable(TableModel table)
        {
            return ClassDeclaration(_databaseIdioms.GetClassName(table.Name))
                    .WithModifiers(
                        TokenList(
                            Token(SyntaxKind.PublicKeyword)))
                    .WithMembers(
                        List(from column in table.Columns
                             select VisitColumn(column)
                            ));
        }

        protected virtual MemberDeclarationSyntax VisitColumn(ColumnModel column)
        {
            return PropertyDeclaration(_typeSyntaxProvider.CreateTypeSyntax(column.DataType, column.IsNullable),
                                       Identifier(_databaseIdioms.GetPropertyName(column.Name)))
                                .WithModifiers(
                                    TokenList(
                                        Token(
                                            TriviaList(
                                                Comment($"// {column.Comment ?? column.Name}")),
                                            SyntaxKind.PublicKeyword,
                                            TriviaList())))
                                .WithAccessorList(
                                    AccessorList(
                                        List(
                                            new AccessorDeclarationSyntax[] {
                                                AccessorDeclaration(
                                                    SyntaxKind.GetAccessorDeclaration)
                                                .WithSemicolonToken(
                                                    Token(SyntaxKind.SemicolonToken)),
                                                AccessorDeclaration(
                                                    SyntaxKind.SetAccessorDeclaration)
                                                .WithSemicolonToken(
                                                    Token(SyntaxKind.SemicolonToken))
                                            })));
        }
    }
}
